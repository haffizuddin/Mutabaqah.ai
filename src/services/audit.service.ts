import { prisma } from '@/lib/prisma';
import { generateAuditSummary } from '@/lib/ai';
import type { Transaction, AuditEvent } from '@/types';

// ===========================================
// Audit Service
// ===========================================

export async function getAuditTimeline(transactionId: string) {
  const transaction = await prisma.transaction.findUnique({
    where: { id: transactionId },
    include: {
      auditEvents: {
        orderBy: { stage: 'asc' },
        include: {
          certificate: true,
        },
      },
      aiAuditSummary: true,
    },
  });

  if (!transaction) {
    throw new Error('Transaction not found');
  }

  return transaction;
}

export async function generateAiAuditSummary(transactionId: string, forceRegenerate = false) {
  const transaction = await prisma.transaction.findUnique({
    where: { id: transactionId },
    include: {
      auditEvents: {
        orderBy: { stage: 'asc' },
        include: { certificate: true },
      },
      aiAuditSummary: true,
    },
  });

  if (!transaction) {
    throw new Error('Transaction not found');
  }

  // Return existing if not forcing regeneration
  if (transaction.aiAuditSummary && !forceRegenerate) {
    return transaction.aiAuditSummary;
  }

  // Convert Prisma types to our domain types
  const domainTransaction: Transaction = {
    id: transaction.id,
    transactionId: transaction.transactionId,
    customerName: transaction.customerName,
    customerId: transaction.customerId,
    commodityType: transaction.commodityType as Transaction['commodityType'],
    amount: Number(transaction.amount),
    currency: transaction.currency,
    status: transaction.status as Transaction['status'],
    shariahStatus: transaction.shariahStatus as Transaction['shariahStatus'],
    createdAt: transaction.createdAt,
    updatedAt: transaction.updatedAt,
  };

  const domainEvents: AuditEvent[] = transaction.auditEvents.map((e) => ({
    id: e.id,
    transactionId: e.transactionId,
    stage: e.stage as AuditEvent['stage'],
    stageName: e.stageName,
    status: e.status as AuditEvent['status'],
    timestamp: e.timestamp,
    completedAt: e.completedAt,
    certificateId: e.certificateId,
    metadata: e.metadata as Record<string, unknown> | null,
  }));

  // Generate AI audit
  const auditResult = await generateAuditSummary({
    transaction: domainTransaction,
    events: domainEvents,
  });

  // Save or update the summary
  const summary = await prisma.aiAuditSummary.upsert({
    where: { transactionId },
    update: {
      summary: auditResult.summary,
      complianceScore: auditResult.complianceScore,
      findings: auditResult.findings,
      recommendations: auditResult.recommendations,
      generatedBy: auditResult.generatedBy,
    },
    create: {
      transactionId,
      summary: auditResult.summary,
      complianceScore: auditResult.complianceScore,
      findings: auditResult.findings,
      recommendations: auditResult.recommendations,
      generatedBy: auditResult.generatedBy,
    },
  });

  // Log the generation
  await prisma.auditLog.create({
    data: {
      transactionId,
      eventType: 'AI_AUDIT_GENERATED',
      message: `AI Shariah audit generated by ${auditResult.generatedBy}`,
      severity: auditResult.complianceScore >= 70 ? 'INFO' : 'WARNING',
      metadata: { score: auditResult.complianceScore },
    },
  });

  return summary;
}

export async function getAuditLogs(
  transactionId?: string,
  options: { page?: number; pageSize?: number; severity?: string } = {}
) {
  const { page = 1, pageSize = 50, severity } = options;

  const where: Record<string, unknown> = {};

  if (transactionId) {
    where.transactionId = transactionId;
  }

  if (severity) {
    where.severity = severity;
  }

  const [logs, total] = await Promise.all([
    prisma.auditLog.findMany({
      where,
      orderBy: { timestamp: 'desc' },
      skip: (page - 1) * pageSize,
      take: pageSize,
      include: {
        transaction: {
          select: {
            transactionId: true,
            customerName: true,
          },
        },
      },
    }),
    prisma.auditLog.count({ where }),
  ]);

  return {
    logs,
    total,
    page,
    pageSize,
    totalPages: Math.ceil(total / pageSize),
  };
}

export async function createAuditLog(
  eventType: string,
  message: string,
  severity: 'INFO' | 'WARNING' | 'ERROR' | 'CRITICAL' = 'INFO',
  transactionId?: string,
  metadata?: Record<string, unknown>
) {
  return prisma.auditLog.create({
    data: {
      transactionId,
      eventType,
      message,
      severity,
      metadata: metadata ? JSON.parse(JSON.stringify(metadata)) : undefined,
    },
  });
}

export async function getRecentAuditLogs(limit = 20) {
  return prisma.auditLog.findMany({
    orderBy: { timestamp: 'desc' },
    take: limit,
    include: {
      transaction: {
        select: {
          transactionId: true,
          customerName: true,
        },
      },
    },
  });
}
